ğŸ§  The core mistake (one sentence)

You mixed â€œdefinitionsâ€ and â€œexecutionâ€ in main.py, then imported it in eval.py.
Python executed the training code automatically.

Thatâ€™s it. Everything else is a consequence.

ğŸ§© Step-by-step: what went wrong from the beginning
1ï¸âƒ£ You wrote a correct training script (main.py)

At first, this was totally fine:

python main.py


Dataset

Model

Training loop

Saving best_model.pth

âœ… No problem as long as main.py is run directly

2ï¸âƒ£ Then you wanted to reuse code in eval.py

Very reasonable idea ğŸ‘

So you wrote:

from main import get_model, CelebADataset, df_test


Here is the critical Python rule that caused everything:

âš ï¸ When you import a file, Python executes it line by line.

Not just functions.
Everything.

3ï¸âƒ£ Your training loop was at top-level

Your main.py originally had:

for epoch in range(NUM_EPOCHS):
    ...


âŒ This is top-level code

So when eval.py did:

import main


Python did this internally:

â†’ open main.py
â†’ execute line 1
â†’ execute line 2
â†’ ...
â†’ start training ğŸ˜±


Thatâ€™s why you saw:

Epoch 1/20 ...


even though you never launched training

4ï¸âƒ£ Why the error appeared only during evaluation

After training finished (or partially ran), eval.py continued and crashed with:

TypeError: default_collate: found PIL.Image.Image


This happened because:

eval.py used CelebADataset

but without transforms

so the DataLoader received PIL images instead of tensors

This error masked the real root cause, which was training being triggered silently.

